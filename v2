import re
import pdfplumber
import pandas as pd
import datetime as dt
from pathlib import Path
from io import BytesIO
import streamlit as st
from openpyxl import load_workbook, Workbook
from openpyxl.styles import PatternFill
from openpyxl.utils import get_column_letter
import unicodedata

# ------------------ PDF parsing helpers ------------------
GREEK_MONTHS = {
    "Ιανουαρίου": 1, "Φεβρουαρίου": 2, "Μαρτίου": 3, "Απριλίου": 4,
    "Μαΐου": 5, "Μαίου": 5, "Ιουνίου": 6, "Ιουλίου": 7, "Αυγούστου": 8,
    "Σεπτεμβρίου": 9, "Οκτωβρίου": 10, "Νοεμβρίου": 11, "Δεκεμβρίου": 12
}
DOW = r"(Δευτέρα|Τρίτη|Τετάρτη|Πέμπτη|Παρασκευή|Σάββατο|Κυριακή)"
DATE_RE = re.compile(DOW + r",?\s+(\d{1,2})\s+([A-ΩA-Za-zΪΫά-ώϊϋΐΰΏΉΈΆΌΊΎΪΫ]+),\s+(\d{4})")

BLOCK_KEYWORDS = [
    "Στοιχεία Συναλλαγών Πακέτων",
    "Πίνακας Προσυμφωνημένων Συναλλαγών",
    "Χρεόγραφα Όγκος πακέτου Τιμή πακέτου Αξία πακέτου Ώρα έγκρισης",
]
TIME_RE = re.compile(r'(\d{2}:\d{2}:\d{2})\s+(\d+)$')

_DEACCENT_TABLE = str.maketrans(
    "ΪΫάέίόύήώϊϋΐΰΆΈΊΎΌΉΏ",
    "ΙΥαειουηωιυιυΑΕΙΥΟΗΩ"
)

def norm_name(s: str) -> str:
    if not isinstance(s, str):
        return s
    s = s.translate(_DEACCENT_TABLE)
    s = re.sub(r"\s+", " ", s.strip())
    s = re.sub(r"\s*\(", " (", s)
    s = re.sub(r"\((ΚΟ|KO)\)", "(KO)", s, flags=re.I)
    s = re.sub(r"\((ΚΑ|KA)\)", "(KA)", s, flags=re.I)
    return s.upper()

def extract_report_date(pdf_file) -> dt.date | None:
    with pdfplumber.open(pdf_file) as pdf:
        for p in pdf.pages:
            text = p.extract_text() or ""
            m = DATE_RE.search(text)
            if m:
                day = int(m.group(2))
                month_name = m.group(3)
                year = int(m.group(4))
                month = GREEK_MONTHS.get(month_name)
                if not month:
                    key = month_name.translate(_DEACCENT_TABLE)
                    fallback = {
                        "Ιανουαριου":1,"Φεβρουαριου":2,"Μαρτιου":3,"Απριλιου":4,
                        "Μαιου":5,"Ιουνιου":6,"Ιουλιου":7,"Αυγουστου":8,
                        "Σεπτεμβριου":9,"Οκτωβριου":10,"Νοεμβριου":11,"Δεκεμβριου":12
                    }
                    month = fallback.get(key)
                if month:
                    return dt.date(year, month, day)
    return None

def locate_block_trade_pages(pdf_file):
    pages = []
    with pdfplumber.open(pdf_file) as pdf:
        for i, p in enumerate(pdf.pages):
            text = p.extract_text() or ""
            if any(k in text for k in BLOCK_KEYWORDS):
                pages.append(i)
    return pages

def parse_block_table_from_page(text: str) -> pd.DataFrame:
    lines = (text or "").splitlines()
    start = None
    for i, ln in enumerate(lines):
        if "Χρεόγραφα" in ln and "Όγκος" in ln and "Ώρα έγκρισης" in ln:
            start = i + 1
            break
    rows = []
    if start is None:
        return pd.DataFrame(columns=["Company","Volume","Price","Value","ApprovalTime","Note"])
    for ln in lines[start:]:
        ln = ln.strip()
        if not ln or "Σημειώσεις" in ln:
            break
        m = TIME_RE.search(ln)
        if not m:
            continue
        time = m.group(1); note = m.group(2)
        left = ln[:m.start()].strip()
        parts = left.split()
        if len(parts) < 4:
            continue
        value_str, price_str, volume_str = parts[-1], parts[-2], parts[-3]
        company = " ".join(parts[:-3])
        rows.append([company, volume_str, price_str, value_str, time, note])
    df = pd.DataFrame(rows, columns=["Company","Volume","Price","Value","ApprovalTime","Note"])
    if not df.empty:
        df["Volume"] = df["Volume"].str.replace(",","", regex=False).astype("int64")
        df["Price"]  = df["Price"].str.replace(",","", regex=False).astype("float64")
        df["Value"]  = df["Value"].str.replace(",","", regex=False).astype("float64")
    return df

def extract_block_trades(pdf_file) -> pd.DataFrame:
    report_date = extract_report_date(pdf_file)
    pages = locate_block_trade_pages(pdf_file)
    frames = []
    with pdfplumber.open(pdf_file) as pdf:
        for idx in pages:
            text = pdf.pages[idx].extract_text() or ""
            df = parse_block_table_from_page(text)
            if not df.empty:
                df.insert(0, "Date", report_date)
                frames.append(df)
    if frames:
        return pd.concat(frames, ignore_index=True)
    return pd.DataFrame(columns=["Date","Company","Volume","Price","Value","ApprovalTime","Note"])

# ------------------ Excel helpers ------------------
def find_or_create_date_row(ws, target_date: dt.date) -> int:
    max_row = ws.max_row or 1
    for r in range(3, max_row + 1):
        val = ws.cell(row=r, column=1).value
        if val is None:
            continue
        try:
            d = pd.to_datetime(val, dayfirst=True).date()
        except Exception:
            continue
        if d == target_date:
            return r
    r = max_row + 1
    ws.cell(row=r, column=1, value=dt.datetime.combine(target_date, dt.time()))
    return r

def read_company_header_positions(ws) -> dict:
    positions = {}
    max_col = ws.max_column
    c = 2
    while c <= max_col:
        header = ws.cell(row=2, column=c).value
        if header and str(header).strip():
            txt = str(header).strip()
            positions[norm_name(txt)] = (c, txt)
        c += 4
    return positions

def group_trades_for_formulas(df: pd.DataFrame) -> dict:
    out = {}
    for _, row in df.iterrows():
        comp = norm_name(str(row["Company"]))
        out.setdefault(comp, {"volumes": [], "prices": []})
        out[comp]["volumes"].append(int(row["Volume"]))
        out[comp]["prices"].append(float(row["Price"]))
    return out

def price_list_greek(prices: list[float]) -> str:
    return "-".join(f"{p:.2f}".replace(".", ",") for p in prices)

def volume_formula(volumes: list[int]) -> str | int:
    if not volumes:
        return None
    if len(volumes) == 1:
        return volumes[0]
    return "=" + "+".join(str(v) for v in volumes)

def fill_row(ws, row_idx: int, header_pos: dict, trades: dict, date_obj: dt.date):
    for comp_norm, (start_col, _hdr) in header_pos.items():
        ws.cell(row=row_idx, column=start_col, value=dt.datetime.combine(date_obj, dt.time()))
        data = trades.get(comp_norm)
        if not data:
            continue
        vols = data["volumes"]
        prices = data["prices"]
        ws.cell(row=row_idx, column=start_col + 1, value=volume_formula(vols))
        ws.cell(row=row_idx, column=start_col + 2, value=len(vols))
        ws.cell(row=row_idx, column=start_col + 3, value=price_list_greek(prices))

def write_pdf_sheet(wb, sheet_name: str, df_pdf: pd.DataFrame, header_pos: dict):
    if sheet_name in wb.sheetnames:
        del wb[sheet_name]
    ws = wb.create_sheet(title=sheet_name)

    df_show = df_pdf.copy()
    df_show["CompanyNorm"] = df_show["Company"].map(norm_name)
    df_show["Matched"] = df_show["CompanyNorm"].apply(lambda x: "Yes" if x in header_pos else "No")

    cols = ["Company","Volume","Price","Value","ApprovalTime","Note","Matched"]
    for j, c in enumerate(cols, start=1):
        ws.cell(row=1, column=j, value=c)

    fill_green = PatternFill(start_color="C6EFCE", end_color="C6EFCE", fill_type="solid")
    fill_red   = PatternFill(start_color="FFC7CE", end_color="FFC7CE", fill_type="solid")

    for i, row in df_show.iterrows():
        vals = [row["Company"], int(row["Volume"]), float(row["Price"]), float(row["Value"]), row["ApprovalTime"], row["Note"], row["Matched"]]
        for j, v in enumerate(vals, start=1):
            ws.cell(row=i+2, column=j, value=v)
        rng = ws.iter_rows(min_row=i+2, max_row=i+2, min_col=1, max_col=len(cols))
        for r in rng:
            for cell in r:
                cell.fill = fill_green if row["Matched"] == "Yes" else fill_red

    for j in range(1, len(cols)+1):
        ws.column_dimensions[get_column_letter(j)].width = 18

# ------------------ Sorting helpers ------------------
def is_greek(text: str) -> bool:
    if not text:
        return False
    return "GREEK" in unicodedata.name(text[0], "")

def sort_headers(headers_map: dict) -> list[tuple[int, str]]:
    items = [(col, hdr) for (_, (col, hdr)) in headers_map.items()]
    return sorted(
        items,
        key=lambda x: (0 if is_greek(x[1]) else 1, x[1])
    )

def reorder_company_blocks(ws):
    headers_map = read_company_header_positions(ws)
    sorted_blocks = sort_headers(headers_map)

    # Collect all data blocks into memory
    blocks = []
    for start_col, hdr in sorted_blocks:
        block_data = []
        for row in ws.iter_rows(min_row=2, max_row=ws.max_row,
                                min_col=start_col, max_col=start_col+3, values_only=True):
            block_data.append(row)
        blocks.append((hdr, block_data))

    # Clear old blocks
    for col in range(2, ws.max_column+1):
        for row in range(2, ws.max_row+1):
            ws.cell(row=row, column=col, value=None)

    # Write back in sorted order
    col_idx = 2
    for hdr, block_data in blocks:
        for row_offset, row_vals in enumerate(block_data):
            for j, val in enumerate(row_vals):
                ws.cell(row=2+row_offset, column=col_idx+j, value=val)
        col_idx += 4

# ------------------ Streamlit App ------------------
st.title("Block Trade Parser")

pdf_file = st.file_uploader("Upload ΗΔΤ PDF", type="pdf")
xlsx_file = st.file_uploader("Upload Block Trades Master Excel", type="xlsx")

if pdf_file and xlsx_file:
    df = extract_block_trades(pdf_file)

    if df.empty:
        st.error("No block trades found in PDF.")
    else:
        st.success(f"Parsed {len(df)} trades from PDF")

        report_date = df.iloc[0]["Date"]
        if isinstance(report_date, pd.Timestamp):
            report_date = report_date.date()
        date_label = report_date.strftime("%d.%m.%Y")

        wb = load_workbook(xlsx_file)
        if "Master" not in wb.sheetnames:
            st.error("Sheet 'Master' not found in Excel.")
        else:
            ws = wb["Master"]
            row_idx = find_or_create_date_row(ws, report_date)
            headers_map = read_company_header_positions(ws)

            trades_map = group_trades_for_formulas(df)
            fill_row(ws, row_idx, headers_map, trades_map, report_date)

            # NEW: reorder company blocks alphabetically (Greek first)
            reorder_company_blocks(ws)

            write_pdf_sheet(wb, date_label, df, headers_map)

            output = BytesIO()
            wb.save(output)

            st.download_button(
                label="⬇ Download updated Excel",
                data=output.getvalue(),
                file_name=f"Block Trades_updated as of {date_label}.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            )
